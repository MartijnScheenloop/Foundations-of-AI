#  (C) Copyright Wieger Wesselink 2021. Distributed under the GPL-3.0-or-later
#  Software License, (See accompanying file LICENSE or copy at
#  https://www.gnu.org/licenses/gpl-3.0.txt)

import random
import time
from competitive_sudoku.sudoku import GameState, Move, SudokuBoard, TabooMove
import competitive_sudoku.sudokuai


class SudokuAI(competitive_sudoku.sudokuai.SudokuAI):
    """
    Sudoku AI that computes a move for a given sudoku configuration.
    """

    def __init__(self):
        super().__init__()

    # N.B. This is a very naive implementation.
    def compute_best_move(self, game_state: GameState) -> None:
        N = game_state.board.N

        def possible(i, j, value):
            #returning the non-empty and non-taboo moves
            return game_state.board.get(i, j) == SudokuBoard.empty \
                   and not TabooMove(i, j, value) in game_state.taboo_moves \
                   and not game_state.board.get(i, j) in SudokuBoard[i,:] \
                   and not game_state.board.get(i, j) in SudokuBoard[:,j] \

        all_moves = [Move(i, j, value) for i in range(N) for j in range(N)
                     for value in range(1, N+1) if possible(i, j, value)]
        move = random.choice(all_moves)
        self.propose_move(move)
        while True:
            time.sleep(0.2)
            self.propose_move(random.choice(all_moves))

    # def evaluate(board) -> None:


    # def getChildren(board, isMaximisingPlayer) -> None:
                
    # def minimax(board, depth, isMaximisingPlayer, score) -> None:
    #     if depth == 0 or depth > board.squares.count(SudokuBoard.empty) or board.squares.count(SudokuBoard.empty) == 0 or not getChildren(board, isMaximisingPlayer):
    #         return score, None
        
    #     children = getChildren(board, isMaximisingPlayer)
    #     if isMaximisingPlayer:
    #         max_value = float('-inf')
    #         for child in children(board, isMaximisingPlayer):
    #             score += child[1]
    #             evaluation, _ = minimax(child[0], depth-1, False, score)
    #             if max_value < evaluation:
    #                 max_value = evaluation
    #                 move = child[2]
    #         return max_value, move
        
    #     else:
    #         min_value = float('inf')
    #         for child in children(board, isMaximisingPlayer):
    #             score += child[1]
    #             evaluation, _ = minimax(child[0], depth-1, True, score)
    #             if min_value > evaluation:
    #                 max_value = evaluation
    #                 move = child[2]
    #         return min_value, move
                